// copyright (c) 2021 yieldingcoder. all rights reserved.
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const ignoreList = ['.git', 'node_modules', 'objects'];
const loop = async v => {
	v = path.resolve(v);
	console.log('Looping in', v);
	const dir = fs.readdirSync(v);
	for (const i in dir) {
		let x = dir[i];
		x = path.join(v, x);
		let ignore = false;
		ignoreList.forEach(v => {
			ignore = ignore || x.split('\\').join('/').split('/').includes(v);
		});
		if (ignore) return;
		if (fs.statSync(x).isDirectory()) {
			await loop(x);
		} else {
			if (
				!x.endsWith('.png') &&
				!x.endsWith('.jpg') &&
				!x.endsWith('.ico') &&
				!x.endsWith('.webp')
			)
				return;
			console.log(1, x);
			if (x.includes('- Lossy') || x.includes('- Lossless')) return;
			console.log(2, x);
			let l = x.split('.');
			l[l.length - 1] = 'modified';
			l = l.join('.');
			const v = (args, outd) => {
				console.log(`Executing Magick with output ${l}.${outd}`);
				return new Promise((resolve, reject) =>
					exec(
						`magick convert ${x} ${args} ${l}.${outd}`,
						(err, stdo, stde) => {
							console.log(
								`Returned for ${l}.${outd}`,
								(err ? `err: ${err}\n` : '') +
									(stdo ? `stdout: ${stdo}\n` : '') +
									(stde ? 'stderr: ' + stde : '')
							);
							if (err) reject(err);
							else resolve();
						}
					)
				);
			};

			const rescale = async s => {
				//await v(`-resize ${s*100}%`,`rescale-${s*100}.png`);
				//await v(`-resize ${s*100}%`,`rescale-${s*100}.jpg`);
				await v(`-resize ${s * 100}%`, `rescale-${s * 100}.webp`);
			};
			//await rescale(3/4);
			//await rescale(2/3);
			await rescale(1 / 2);
			//await rescale(1/3);
			//await rescale(1/4);
			//await rescale(1/5);
			//await rescale(1/6);
		}
	}
};
loop('img');
