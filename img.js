// copyright (c) 2021 yieldingcoder. all rights reserved.
const fs = require('fs')
const path = require('path')
const {exec} = require('child_process')
const ignoreList = ['.git','node_modules','objects']
const loop = (v)=>{
  v=path.resolve(v);
  console.log('Looping in',v);
  const dir = fs.readdirSync(v);
  for (const i in dir) {
    let x = dir[i];
    x=path.join(v,x);
    let ignore = false;
    ignoreList.forEach((v)=>{
      ignore=ignore || x.split('\\').join('/').split('/').includes(v);
    });
    if (ignore) return;
    if (fs.statSync(x).isDirectory()) loop(x);
    else {
      if (!x.endsWith('.png')&&!x.endsWith('.jpg')&&!x.endsWith('.ico')&&!x.endsWith('.webp')) return;
      if (x.includes('- Lossy') || x.includes('- Lossless')) return;
      const dt = fs.readFileSync(x).toString('base64');
      let l = x.split('.');
      l[l.length-1]='modified';
      l=l.join('.');
      const v=(args,outd)=>{
        console.log(`Executing Magick with output ${l}.${outd}`);
        return new Promise((resolve,reject)=>exec(
            `magick convert ${x} ${args} ${l}.${outd}`,
            (err,stdo,stde)=>{
              console.log(
                `Returned for ${l}.${outd}`,
                (err?`err: ${err}\n`:'')+
                (stdo?`stdout: ${stdo}\n`:'')+
                (stde?'stderr: '+stde:'')
              );
              if (err) reject(err);
              else resolve();
            };
          );
        });
      };
        
      const rescale = (s)=>{
//         v(`-resize ${s*100}%`,`rescale-${s*100}.png`);
//         v(`-resize ${s*100}%`,`rescale-${s*100}.jpg`);
        v(`-resize ${s*100}%`,`rescale-${s*100}.webp`);
      }
//       rescale(3/4);
//       rescale(2/3);
      rescale(1/2);
//       rescale(1/3);
//       rescale(1/4);
//       rescale(1/5);
//       rescale(1/6);
    };
  });
};
loop('img');
