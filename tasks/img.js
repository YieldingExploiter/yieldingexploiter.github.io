// copyright (c) 2021 yieldingcoder. all rights reserved.
const fs = require('fs-extra');
const path = require('path');
const { exec } = require('child_process');
const ignoreList = ['.git', 'node_modules', 'objects'];

const extensionOut = {
	png: [100, 75, 66, 50, 33, 25],
	jpg: [100, 75, 50, 25],
	webp: [100, 75, 50, 25, 10],
	gif: [100, 75, 50, 10],
};
const extList = [];
for (const ext in extensionOut) {
	if (Object.hasOwnProperty.call(extensionOut, ext)) {
		const i = extensionOut[ext];
		extList[extList.length] = {
			name: ext,
			res: i,
		};
	}
}
let count = 0;
let imgsdone = 0;
const startLoop = (dir, dry) => {
	if (dry) {
		count = 0;
		console.log('--- DRY RUN ---');
	} else {
		imgsdone = 0;
		console.log('--- START ---');
	}
	return loop(dir, dry);
};
const loop = async (v, dry) => {
	v = path.resolve(v);
	console.log('Looping in', v);
	const dir = fs.readdirSync(v);
	for (const i in dir) {
		await (async () => {
			let x = dir[i];
			x = path.join(v, x);
			let ignore = x.includes(' - Scaled');
			ignoreList.forEach(v => {
				ignore = ignore || x.split('\\').join('/').split('/').includes(v);
			});
			if (ignore) return;
			if (fs.statSync(x).isDirectory()) {
				return await loop(x, dry);
			} else {
				if (
					!x.endsWith('.png') &&
					!x.endsWith('.jpg') &&
					!x.endsWith('.jpeg') &&
					!x.endsWith('.ico') &&
					!x.endsWith('.gif') &&
					!x.endsWith('.xcf') &&
					!x.endsWith('.webp')
				)
					return;
				if (x.includes('.modified')) return fs.unlinkSync(x);
				if (
					x.includes('- Lossy') ||
					x.includes('- Lossless') ||
					x.includes('.mod') ||
					x.includes('- Scaled')
				)
					return;
				let splitL = x.split('\\').join('/').split('/');
				splitL[splitL.length - 1] = splitL[splitL.length - 1] + ' - Scaled';
				const l = splitL.join('/');
				const v = (scale, outd) => {
					const out = `${l}/${outd}`;

					const doReadme = () => {
						const _v = path.resolve(out, '..', 'README.md');
						const u = ext => {
							let v = out.split('\\').join('/').split('/');
							v = v[v.length - 1].split('.');
							v.pop();
							const filename = `${v.join('.')}.${ext}`;
							return `[![File ${filename}](${filename})](${filename})`;
						};
						const extLs = extList.filter(v => v.res.includes(scale));
						fs.writeFileSync(
							_v,
							`# Image \`${splitL[splitL.length - 1]
								.replace(/\\/g, '/')
								.replace(' - Scaled', '` (Scaled)')}\n
\`\`\`yml
Scale Percentage: ${scale}
Scaled Using: ImageMagick
\`\`\`

Files:
<!--
| ${extLs.map(v => v.name + ' | ').join('')}
| ${extLs.map(_ => '--- | ').join('')}
| ${extLs.map(v => u(v.name) + ' | ').join('')}
-->
${extLs.map(v => '<br/>' + v.name + ':\n> ' + u(v.name)).join('')}
`
						);
					};

					if (fs.existsSync(out)) {
						if (!dry) {
							console.log(
								`[${imgsdone}/${count}] ${out} already exists! Skipping...`
							);
							doReadme();
						}
						return new Promise(r => r());
					}
					if (dry) {
						count++;
						return;
					}
					fs.ensureFileSync(out);

					doReadme();

					const cmd =
						(process.platform == 'win32' ? '' : 'magick ') +
						`convert "${x}" -resize ${scale}% "${out}"`;
					console.log(`[${imgsdone}/${count}] Executing ${cmd}`);
					const promsieFunc = (resolve, reject, runs) =>
						exec(cmd, (err, stdo, stde) => {
							console.log(
								`[${imgsdone}/${count}] Returned for ${out}`,
								(err ? `err: ${err}\n` : '') +
									(stdo ? `stdout: ${stdo}\n` : '') +
									(stde ? 'stderr: ' + stde : '')
							);
							imgsdone++;
							if (err) {
								console.error(`Error for ${out}:`, err);
								console.error(`Attempts: ${runs ?? 1}/5`);

								if (runs ?? 1 >= 5) return reject(err);

								promsieFunc(resolve, reject, (runs ?? 0) + 1);
							}
							return resolve();
						});
					return new Promise(promsieFunc);
				};

				const rescale = async (e, s) => {
					await v(s, `${s}/Image.${e}`);
				};
				await new Promise(resolve => {
					for (const key in extensionOut) {
						if (Object.hasOwnProperty.call(extensionOut, key)) {
							const ext = extensionOut[key];
							ext.forEach(res => {
								rescale(key, res).then(resolve);
							});
						}
					}
				});
			}
		})();
	}
};
(async () => {
	await startLoop('img', true);
	await startLoop('img', false);
})();
