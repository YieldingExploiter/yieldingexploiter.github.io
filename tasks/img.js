// copyright (c) 2021 yieldingcoder. all rights reserved.
const fs = require('fs-extra');
const path = require('path');
const { exec } = require('child_process');
const ignoreList = ['.git', 'node_modules', 'objects'];

const extensionOut = {
	png: [100, 75, 66, 50, 33, 25],
	jpg: [100, 75, 50, 25],
	webp: [100, 75, 50, 25, 10],
	gif: [100, 75, 50, 10],
};
let count = 0;
let imgsdone = 0;
const startLoop = (dir, dry) => {
	if (dry) {
		count = 0;
		console.log('--- DRY RUN ---');
	} else {
		imgsdone = 0;
		console.log('--- START ---');
	}
	return loop(dir, dry);
};
const loop = async (v, dry) => {
	v = path.resolve(v);
	console.log('Looping in', v);
	const dir = fs.readdirSync(v);
	for (const i in dir) {
		await (async () => {
			let x = dir[i];
			x = path.join(v, x);
			let ignore = false;
			ignoreList.forEach(v => {
				ignore = ignore || x.split('\\').join('/').split('/').includes(v);
			});
			if (ignore) return;
			if (fs.statSync(x).isDirectory()) {
				return await loop(x, dry);
			} else {
				if (
					!x.endsWith('.png') &&
					!x.endsWith('.jpg') &&
					!x.endsWith('.jpeg') &&
					!x.endsWith('.ico') &&
					!x.endsWith('.gif') &&
					!x.endsWith('.xcf') &&
					!x.endsWith('.webp')
				)
					return;
				if (x.includes('.modified')) return fs.unlinkSync(x);
				if (
					x.includes('- Lossy') ||
					x.includes('- Lossless') ||
					x.includes('.mod') ||
					x.includes('- Scaled')
				)
					return;
				let splitL = x.split('\\').join('/').split('/');
				splitL[splitL.length - 1] = splitL[splitL.length - 1] + ' - Scaled';
				const l = splitL.join('/');
				const v = (scale, outd) => {
					const out = `${l}/${outd}`;
					if (fs.existsSync(out)) {
						if (!dry)
							console.log(
								`[${imgsdone}/${count}] ${out} already exists! Skipping...`
							);
						return new Promise(r => r());
					}
					if (dry) {
						count++;
						return;
					} else imgsdone++;
					fs.ensureFileSync(`${l}/${outd}`);
					const cmd =
						(process.platform == 'win32' ? '' : 'magick ') +
						`convert "${x}" -resize ${scale}% "${out}"`;
					console.log(`[${imgsdone}/${count}] Executing ${cmd}`);
					return new Promise((resolve, reject) =>
						exec(cmd, (err, stdo, stde) => {
							console.log(
								`[${imgsdone}/${count}] Returned for ${out}`,
								(err ? `err: ${err}\n` : '') +
									(stdo ? `stdout: ${stdo}\n` : '') +
									(stde ? 'stderr: ' + stde : '')
							);
							if (err) return reject(err);
							else {
								const _v = path.resolve(out, '..', 'README.md');
								if (!fs.existsSync(_v)) {
									const u = ext => {
										let v = out.split('\\').join('/').split('/');
										v = v[v.length - 1].split('.');
										v.pop();
										const filename = `${v.join('.')}.${ext}`;
										return `[![File ${filename}](${filename})](${filename})`;
									};
									fs.writeFileSync(
										_v,
										`# Image ${splitL[splitL.length - 1]
											.replace(/\\/g, '/')
											.replace(' - Scaled', ' (Scaled)')}\n
\`\`\`yml
Scale Percentage: ${scale}
Scaled Using: ImageMagick
Scaled On/At: ${new Date().toString()}
\`\`\`

Files:
| JPEG        | PNG         | WEBP         | GIF         |
| ----------- | ----------- | ------------ | ----------- |
| ${u('jpg')} | ${u('png')} | ${u('webp')} | ${u('gif')} |
`
									);
								}
								return resolve();
							}
						})
					);
				};

				const rescale = async (e, s) => {
					await v(s, `${e}/${s} Percent.${e}`);
				};
				await new Promise(resolve => {
					for (const key in extensionOut) {
						if (Object.hasOwnProperty.call(extensionOut, key)) {
							const ext = extensionOut[key];
							ext.forEach(res => {
								rescale(key, res).then(resolve);
							});
						}
					}
				});
			}
		})();
	}
};
(async () => {
	await startLoop('img', true);
	await startLoop('img', false);
})();
